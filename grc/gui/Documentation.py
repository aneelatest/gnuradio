

"""
Copyright 2007, 2008, 2009 Free Software Foundation, Inc.
This file is part of GNU Radio

GNU Radio Companion is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

GNU Radio Companion is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
"""

import pygtk
pygtk.require('2.0')
import gtk
import webbrowser
import urllib2
import httplib
import urlparse
from sgmllib import SGMLParser
import urllib
from Dialogs import MessageDialogHelper
from gnuradio import gr
import re
import os
from os.path import expanduser, walk
from Messages import open_doc_and_code_message



class open_document_and_source_code():


	def __init__(self):
		
		self.get_webpage = webbrowser.get() 
		self.sph=gr.prefs().get_string('grc', 'sphinx_base_uri', '')
		self.dox=gr.prefs().get_string('grc', 'doxygen_base_uri', '')
		self.path=gr.prefs().get_string('grc', 'source_path', '')	
		self.data1_doc=['add_vcc','multiply_vcc','fir_filter_ccf']
		self.data2_doc=['add_cc','multiply_cc','firdes']	
		self.data1_code=['psk_mod','psk_demod','qam_mod','qam_demod','ofdm_tx','ofdm_rx','gmsk_mod','gmsk_demod','gfsk_mod','gfsk_demod','dbpsk_mod','dbpsk_demod','packet_mod_f','packet_demod_f','fir_filter_ccf']
		self.data2_code=['psk','qam','ofdm_txrx','gmsk','gfsk','bpsk','ofdm','firdes']
		

	def open_document(self,block):

		block_info=block.get_make()
		python_block=True
		check=False
		try:
			block_info_part=block_info.split('(')[0].split('.')
			
	 		class_name=block_info_part[0]
			if len(block_info_part)==3:
				block_name=block_info_part[2]
			else:
				block_name=block_info_part[1]
			
			#############################################################################################
			#For add, multiply, low pass, band pass, band reject, root raised cosine, band stop blocks
			#############################################################################################
			i=0
			for blk in self.data1_doc:
				if re.match(block_name, self.data1_doc[i]):	
					block_name=self.data2_doc[i]
					break
				i=i+1
                        ############################################################################################		
			#block name as in doxygen docs
			block_name_d=""
			block_name_parts=block_name.split('_')
			for i in range(0,len(block_name_parts)):
				if i==len(block_name_parts)-1:
					block_name_d=block_name_d+block_name_parts[i]
				else:
					block_name_d=block_name_d+block_name_parts[i]+'__'
			module_base_path=gr.prefs().get_string(class_name, 'doc_path', '')
			url_lst_d=self.index(self.dox,'annotated.html')
			url_lst_s=self.index(self.sph,'genindex.html')

			if url_lst_s: 	
				for url in url_lst_s.urls:
					if block_name+"_sptr" in url:
						python_block=False
			#doxygen doc
			complete_url=self.get_valid_uri(block_name_d,class_name,url_lst_d,self.dox)
			if complete_url is not None:
				check=True
				open_doc_and_code_message('>>> Opening:  %s\n\n'%complete_url)
				self.get_webpage.open(complete_url)
			#sphinx doc
			else:	
				complete_url=self.get_valid_uri(block_name,class_name,url_lst_s,self.sph)
				if complete_url is not None:
					check=True
					open_doc_and_code_message('>>> Opening:  %s\n\n'%complete_url)
					self.get_webpage.open(complete_url)				
			#blocks from out of tree modules
			if check is False:
				if module_base_path is not '':
					complete_url=self.out_of_tree_module(module_base_path,block_name_d)
					if complete_url is not None:
						open_doc_and_code_message('>>> Opening:  %s\n\n'%complete_url)
						self.get_webpage.open(complete_url)
					else:
						Errorbox("""<b>Documentation of this block is not generated by CMake</b>""")		
				#file does not exist	
				else:
					if not url_lst_s and not url_lst_d:
						Errorbox("""<b>Internet connection is not available and index files annotated.html and genindex.html are not found in this system</b>""")	
					if url_lst_s and url_lst_d:
						Errorbox("""<b>Documentation of selected block is not available</b>""")
					if not url_lst_d and url_lst_s and python_block is False:
						Errorbox("""<b>Internet connection is not available and index file annotated.html is not found in this system</b>""")
					if not url_lst_d and url_lst_s and python_block is True:
						Errorbox("""<b>Documentation of selected block is not available</b>""")
					if not url_lst_s and url_lst_d:
						Errorbox("""<b>Internet connection is not available and index file genindex.html is not found in this system</b>""")	
		except IndexError as e:
			Errorbox("""<b>Documentation of selected block is not available</b>""")
	
	
	def out_of_tree_module(self,address,name_d):
		uri=""
		try: 
			open_index = urllib.urlopen("file://"+address+'annotated.html')
		except IOError as e:
			open_index = []
		if not open_index:
			return None
		else:
			url_list = URLLister()
			url_list.feed(open_index.read())
			url_list.close()
			open_index.close()
			for url in url_list.urls: 
					if name_d in url.lower(): 
						if re.search(name_d+".html"+"\Z", url):
							uri=url
							break
			if uri is not "":
				complete_uri=address+uri
				try:	
					with open(complete_uri): 
						return "file://"+complete_uri
				except IOError:
					return None
			else:
				return None
				


	

	#makes complete uri and checks if uri exists or file at this location exits		
	def get_valid_uri(self,name,class_n,lst,base_uri):
		uri=""
		if lst:
			for url in lst.urls: 
				if name in url.lower(): 
					if "doxygen" in base_uri:
						if class_n in url.lower() and re.search(name+".html"+"\Z", url):
							uri=url
							break
					elif re.search('\.'+name+"\Z", url):
						uri=url
						break
			if uri is not "":
				complete_uri=base_uri.split(',')[1]+uri
				#for remote copy of doc
				if self.network_connection() is True:
					if self.check_url(complete_uri) is True:
						return complete_uri
				#for local copy of doc
				else:
					try:
						if "sphinx" in base_uri.lower():
							complete_uri=base_uri.split(',')[0]+uri
							uri_check=complete_uri.split("#")[0]
						else:
							complete_uri=base_uri.split(',')[0]+uri
							uri_check=complete_uri
						with open(uri_check): 
							return "file://"+complete_uri
					except IOError:
						return None
			else:
				return None
		else:
			return None
	#returns a list of url's in html file
	def index(self,index_page,html_file):
		try:
			open_index = urllib.urlopen(index_page.split(',')[1]+html_file)
		except IOError as e:
			try:
				open_index = urllib.urlopen("file://"+index_page.split(',')[0]+html_file)
			except IOError as e:
				return []
		url_list = URLLister()
		url_list.feed(open_index.read())
		url_list.close()
		open_index.close()
		return url_list

	#checks network connection
	def network_connection(self):
		network=False
		try:
		    response = urllib2.urlopen("http://google.com", None, 2.5)
		    network=True
	
		except urllib2.URLError, e:
		    pass
		return network


	
	def get_server_status_code(self,url):

	    host, path = urlparse.urlparse(url)[1:3]    
	    try:
		conn = httplib.HTTPConnection(host)
		conn.request('HEAD', path)
		return conn.getresponse().status
	    except StandardError:
		return None
	

	#checks valid url 
	def check_url(self,url):
	    
	    good_codes = [httplib.OK, httplib.FOUND, httplib.MOVED_PERMANENTLY]
	    return self.get_server_status_code(url) in good_codes



	def open_source_code(self,block):
		block_info=block.get_make()
		check_find=False
		OTM_check_find=False
		try:
			block_info_part=block_info.split('(')[0].split('.')
			class_name=block_info_part[0]
			if len(block_info_part)==3:
				block_name=block_info_part[2]
			else:
				block_name=block_info_part[1]
			block_c=block_name+"_impl.cc"
			block_p=block_name+".py"
			####################################################################################################
			#For qpsk_mod, qpsk_demod, psk_mod, psk_demod, qam_mod, qam_demod, gmsk_mod, gmsk_demod, low pass, 
			#band pass,band reject, root raised cosine, band stop, ofdm_mod, ofdm_demod, qpsk_mod, qpsk_demod, 
			#gfsk_mod, gfsk_demod, ofdm_tx, ofdm_rx blocks
			####################################################################################################	
			i=0
			for blk in self.data1_code:
				if re.match(block_name, blk):
					block_p=self.data2_code[i/2]+'.py'
					block_c=self.data2_code[i/2]+'.cc'
					break
				i=i+1
			####################################################################################################
			if os.path.isdir(self.path):
				for dirs, subdirs, files in os.walk(self.path):
					for f in files:
						if os.path.isfile(os.path.join(dirs, block_c)) is True:
							check_find=True
							open_doc_and_code_message('>>> Opening:  %s\n\n'%os.path.join(dirs, block_c))
							os.system("gedit "+os.path.join(dirs, block_c))
							break
						if os.path.isfile(os.path.join(dirs, block_p)) is True:
							open_doc_and_code_message('>>> Opening:  %s\n\n'%os.path.join(dirs, block_p))
							check_find=True
							os.system("gedit "+os.path.join(dirs, block_p))
							break
			path=gr.prefs().get_string(class_name, 'module_path', '')
			if os.path.isdir(path) and check_find is False:
				for dirs, subdirs, files in os.walk(path):
					for f in files:
						if os.path.isfile(os.path.join(dirs, block_c)) is True:
							OTM_check_find=True
							open_doc_and_code_message('>>> Opening:  %s\n\n'%os.path.join(dirs, block_c))
							os.system("gedit "+os.path.join(dirs, block_c))
							break
			
				
			if os.path.isdir(self.path) is False and os.path.isdir(path) is False:
				Errorbox("""<b>GNU Radio source tree does not exist in this system</b>""")
			elif OTM_check_find is False and check_find is False:
				Errorbox("""<b>Source code of selected block is not available</b>""")

		except IndexError as e:
			Errorbox("""<b>Source code of selected block is not available</b>""")

def Errorbox(err_msg): MessageDialogHelper(
type=gtk.MESSAGE_ERROR,
buttons=gtk.BUTTONS_CLOSE,
title='Error',
markup=err_msg)


class URLLister(SGMLParser):
	def reset(self):
		SGMLParser.reset(self)
		self.urls = []

	def start_a(self, attrs):
		href = [v for k, v in attrs if k=='href']
		if href:
			self.urls.extend(href)


